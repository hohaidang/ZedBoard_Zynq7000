#include "bme280_driver.hpp"
#include "gpio_driver.hpp"
#include "spi_driver.hpp"
#include <array>

s32 user_spi_read(const u8, u8 *, u32);
s32 user_spi_write(const u8, const u8 *, u32);
void user_delay_ms(u32 period);

gpio_handler button, led;
spi_handler spi0;
bme_sensor_handler bme280(user_spi_read, user_spi_write, user_delay_ms);

void small_delay() {
  for (u32 i = 0; i < 500000000; ++i) {
  }
}

void gpio_init() {
  if (XST_SUCCESS != button.init(XPAR_BUTTON_DEVICE_ID, 1, 0xff)) {
    xil_printf("Button Initial failed\r\n");
    return;
  }
  if (XST_SUCCESS != led.init(XPAR_LED_DEVICE_ID, 1, 0x00)) {
    xil_printf("Led initial failed\r\n");
    return;
  }
}

void spi_init() {
  if (XST_SUCCESS != spi0.init(XPAR_XSPIPS_0_DEVICE_ID)) {
    xil_printf("SPI Initial failed\r\n");
    return;
  }
  if (XST_SUCCESS != spi0.irq_init(XPAR_XSPIPS_0_INTR)) {
    xil_printf("SPI irq initial failed\r\n");
    return;
  }
}

void user_delay_ms(u32 period) {
  // TODO: Add later
  small_delay();
}

s32 user_spi_read(const u8 reg_addr, u8 *reg_data, u32 len) {
  s32 status = XST_FAILURE;
  std::array<u8, BME280_MAX_SIZE_WR> tx_buffer{};
  std::array<u8, BME280_MAX_SIZE_WR> rx_buffer{};

  tx_buffer[0] = reg_addr;
  status = spi0.set_slave_select(0);
  if (XST_SUCCESS != status) {
    xil_printf("Slave select failed\r\n");
    return status;
  }
  status = spi0.irq_transfer(tx_buffer.begin(), rx_buffer.begin(), len + 1);
  if (XST_SUCCESS != status) {
    xil_printf("SPI transfer failed\r\n");
    return status;
  }
  for (u32 i = 0; i < len; ++i)
    reg_data[i] = rx_buffer[i + 1];
  return status;
}

s32 user_spi_write(const u8 reg_addr, const u8 *reg_data, u32 len) {
  s32 status = XST_FAILURE;
  std::array<u8, BME280_MAX_SIZE_WR> tx_buffer{};
  tx_buffer[0] = reg_addr;
  for (u32 i = 0; i < len; ++i) {
    tx_buffer[i + 1] = reg_data[i];
  }
  status = spi0.set_slave_select(0);
  if (XST_SUCCESS != status) {
    xil_printf("Slave select failed\r\n");
    return status;
  }
  status = spi0.irq_transfer(tx_buffer.begin(), nullptr, len + 1);
  if (XST_SUCCESS != status) {
    xil_printf("SPI transfer failed\n\r");
    return status;
  }
  return status;
}

// void spi_write() {
//  u64 data = 0x0102030405060708;
//  std::array<u8, 8> data_out;
//  std::array<u8, 8> data_in;
//
//  memset(data_in.begin(), 0x33, data_in.size());
//  memcpy(data_out.begin(), &data, sizeof(data));
//  if (XST_SUCCESS !=
//      spi0.irq_transfer(data_out.begin(), data_in.begin(), data_out.size())) {
//    xil_printf("SPI transmit failed\r\n");
//    return;
//  }
//  for (int i = 0; i < 8; ++i) {
//    xil_printf("%d ", data_out[i]);
//  }
//}

int main(void) {
  xil_printf("Program Starting\r\n");
  bme280_settings temp{0};
  gpio_init();
  spi_init();
  xil_printf("Peripheral device initial completed\r\n");

  bme280.init_BME280();
  if (SENSOR_OK == bme280.get_status()) {
    bme280.setSensorMode(BME280_NORMAL_MODE);
    bme280_settings settings;
    settings.osr_h = 0x07; // x16
    settings.osr_t = 0x07; // x16
    settings.osr_p = 0x07; // x16
    bme280.set_sensor_settings(settings);
    bme280.get_sensor_settings(temp);
    while (1) {
      bme280.get_sensor_data();
#ifdef DEBUG_EN
      bme280.print_sensor_data();
#endif
      small_delay(); // TODO: add system tick delay later
    }
  } else {
    xil_printf(
        "Sensor Init failed. Please check again hardware connection pins\r\n");
  }
  //  while (1) {
  //    if (button.read()) {
  //      spi_write();
  //      led.toggle(0xff);
  //      small_delay();
  //    }
  //  }
  return XST_SUCCESS;
}
