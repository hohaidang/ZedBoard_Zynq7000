#include "bme280_driver.hpp"
#include "gpio_driver.hpp"
#include "spi_driver.hpp"
#include "xscuwdt.h"
#include "sleep.h"
#include <array>

s32 user_spi_read(const u8, u8 *, u32);
s32 user_spi_write(const u8, const u8 *, u32);
void user_delay_ms(u32 period);

gpio_handler button, led;
spi_handler spi0;
bme_sensor_handler bme280(user_spi_read, user_spi_write, user_delay_ms);
XScuWdt wdi;
XScuWdt_Config *wdC;


void small_delay() {
  for (u32 i = 0; i < 50000000; ++i) {
  }
}

void gpio_init() {
  if (XST_SUCCESS != button.init(XPAR_BUTTON_DEVICE_ID, 1, 0xff)) {
    xil_printf("Button Initial failed\r\n");
    return;
  }
  if (XST_SUCCESS != led.init(XPAR_LED_DEVICE_ID, 1, 0x00)) {
    xil_printf("Led initial failed\r\n");
    return;
  }
}

void spi_init() {
  if (XST_SUCCESS != spi0.init(XPAR_XSPIPS_0_DEVICE_ID, XSPIPS_CLK_PRESCALE_32)) {
    xil_printf("SPI Initial failed\r\n");
    return;
  }
  if (XST_SUCCESS != spi0.irq_init(XPAR_XSPIPS_0_INTR)) {
    xil_printf("SPI irq initial failed\r\n");
    return;
  }
}

void user_delay_ms(u32 period) {
  // TODO: Add later
  small_delay();
  usleep(period * 1000);
}

s32 user_spi_read(const u8 reg_addr, u8 *reg_data, u32 len) {
  s32 status = XST_FAILURE;
  std::array<u8, BME280_MAX_SIZE_WR> tx_buffer{};
  std::array<u8, BME280_MAX_SIZE_WR> rx_buffer{};

  tx_buffer[0] = reg_addr;
  status = spi0.set_slave_select(0);
  if (XST_SUCCESS != status) {
    xil_printf("Slave select failed\r\n");
    return status;
  }
  status = spi0.irq_transfer(tx_buffer.begin(), rx_buffer.begin(), len + 1);
  if (XST_SUCCESS != status) {
    xil_printf("SPI transfer failed\r\n");
    return status;
  }
  for (u32 i = 0; i < len; ++i)
    reg_data[i] = rx_buffer[i + 1];
  return status;
}

s32 user_spi_write(const u8 reg_addr, const u8 *reg_data, u32 len) {
  s32 status = XST_FAILURE;
  std::array<u8, BME280_MAX_SIZE_WR> tx_buffer{};
  tx_buffer[0] = reg_addr;
  for (u32 i = 0; i < len; ++i) {
    tx_buffer[i + 1] = reg_data[i];
  }
  status = spi0.set_slave_select(0);
  if (XST_SUCCESS != status) {
    xil_printf("Slave select failed\r\n");
    return status;
  }
  status = spi0.irq_transfer(tx_buffer.begin(), nullptr, len + 1);
  if (XST_SUCCESS != status) {
    xil_printf("SPI transfer failed\n\r");
    return status;
  }
  return status;
}


int main(void) {
  xil_printf("Program Starting\r\n");
  bme280_settings temp{0};
  gpio_init();
   spi_init();
   xil_printf("Peripheral device initial completed\r\n");

   bme280.init_BME280();
   if (SENSOR_OK == bme280.get_status()) {
     bme280.setSensorMode(BME280_NORMAL_MODE);
     bme280_settings settings;
     settings.osr_h = 0x07; // x16
     settings.osr_t = 0x07; // x16
     settings.osr_p = 0x07; // x16
     bme280.set_sensor_settings(settings);
     bme280.get_sensor_settings(temp);
     while (1) {
       bme280.get_sensor_data();
 #ifdef DEBUG_EN
       bme280.print_sensor_data();
 #endif
       small_delay(); // TODO: add system tick delay later
     }
   } else {
     xil_printf(
         "Sensor Init failed. Please check again hardware connection pins\r\n");
   }
//  int temp = 0;
  // s32 status = XST_FAILURE;
  // wdC = XScuWdt_LookupConfig(XPAR_PS7_SCUWDT_0_DEVICE_ID);
  // status = XScuWdt_CfgInitialize(&wdi, wdC, XPAR_PS7_SCUWDT_0_BASEADDR);
  // if(XST_SUCCESS != status) {
  //   xil_printf("Watchdog timmer initialize failed\r\n");
  //   return status;
  // }
  // XScuWdt_SetWdMode(&wdi);
  // /// 333Mhz 1/333MHz * 333MHz = 1 second
  // u32 count = 333333333 * 10; //
  // XScuWdt_LoadWdt(&wdi, count);
  // XScuWdt_Start(&wdi);
//  while(temp < 10) {
//    sleep(2);
//    led.toggle(0xff);
//  }
  return XST_SUCCESS;
}
